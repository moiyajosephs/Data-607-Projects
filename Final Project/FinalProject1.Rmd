---
title: "Untitled"
author: "Moiya Josephs"
date: "5/12/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(recommenderlab)
library(tidyverse)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:



Original rating is 2,023,070 values. 
```{r}
ratings <- read.csv("C:/Users/josep/OneDrive/Documents/Data-607-Projects/Final Project/ratings_Beauty.csv", header = TRUE, sep = ",", dec = ".")

```




Check the class for each column since pare matrix and real matrix are very particular.

```{r}
class(ratings$UserId); class(ratings$ProductId); class(ratings$Rating); class(ratings$Timestamp)
```


had to change this  to factors
```{r}
ratings$UserId<- as.factor(ratings$UserId); 
ratings$ProductId <- as.factor(ratings$ProductId)
```

Convert into ratings matrix

```{r}
ratingsMatrix <- sparseMatrix(as.integer(ratings$UserId), as.integer(ratings$ProductId), x = ratings$Rating)
colnames(ratingsMatrix) <- levels(ratings$ProductId)
rownames(ratingsMatrix) <- levels(ratings$UserId)
amazon <- as(ratingsMatrix, "realRatingMatrix") #change to beauty
```

```{r}
getRatingMatrix(amazon)[1:10,1:4]
```

```{r}
table(rowCounts(amazon))
```

```{r}
table(colCounts(amazon))
```


```{r}
getRatings(amazon)
```



```{r}
getRatingMatrix(amazon)[1:10,1:4]
```

```{r}
amazon <- amazon[,colCounts(amazon) >30]
```

```{r}
amazon <- amazon[rowCounts(amazon) > 10, ]
amazon
```


```{r}
( amazon <- amazon[ , colCounts(amazon) != 0] )
```


# Build the model


```{r}
train_proportion <- .75
min(rowCounts(amazon))
```



```{r}
items_per_test_user_keep <- 11
# What's a good rating for a binary split?
good_threshold <- 4
```

```{r}
# Building a Recommender System with R by Gorakala and Usuelli. Ch.4 pp 77 - 83
set.seed(12345)
beauty_evaluation <- amazon %>% evaluationScheme(method = 'split', # single train/test split
                   train = train_proportion, # proportion of rows to train.
                   given = items_per_test_user_keep, # shouldn't keep n rec. items > min(rowCounts(movie_r))
                   goodRating = good_threshold, # for binary classifier analysis.
                   k = 1)
```



```{r}
# Building a Recommender System with R by Gorakala and Usuelli. Ch.4 pp 84
model_params <- list(method = "cosine",
                     nn = 10, # find each user's 10 most similar users.
                     sample = FALSE, # already did this.
                     normalize = "center")

model1 <- getData(beauty_evaluation, "train") %>% #only fit on the 75% training data.
  Recommender(method = "UBCF", parameter = model_params)
```



# Divide the data

```{r}
set.seed(88)
train <- getData(beauty_evaluation, "train")
known <- getData(beauty_evaluation, "known")
unknown <- getData(beauty_evaluation, "unknown")
```


```{r}
model_method <- "POPULAR"
# Training

modelPOP <- Recommender(train, method = model_method)
```


```{r}

predPOP <- predict(modelPOP, newdata = known, type = "ratings")


# Accuracy
accPOP <- calcPredictionAccuracy(predPOP, unknown)
```



```{r}
accPOP
```

# USBF

```{r}
set.seed(88)
train <- getData(beauty_evaluation, "train")
known <- getData(beauty_evaluation, "known")
unknown <- getData(beauty_evaluation, "unknown")
```


```{r}
model_method <- "RANDOM"
# Training

modelPOP <- Recommender(train, method = model_method)
```


```{r}

predPOP <- predict(modelPOP, newdata = known, type = "ratings")


# Accuracy
accPOP <- calcPredictionAccuracy(predPOP, unknown)
```



```{r}
accPOP

```






# Conclusions



----------------

#my own dta

source:

python code


```{r}
movie1<- read.delim("C:/Users/josep/movie data/2.txt", header = FALSE, sep = ",", dec = ".")
# add movie id
movie1<- movie1[,c(1,2)]
movie_id <- rep(c(1),547)
movie1<- cbind(movie_id,movie1)
```

```{r}
movie_id <- rep(c(2),145)
movie2<- read.delim("C:/Users/josep/movie data/3.txt", header = FALSE, sep = ",", dec = ".")
movie2<- movie2[,1:2]
movie2<- cbind(movie_id,movie2)
```


```{r}
movie_id <- rep(c(3),2012)
movie3<- read.delim("C:/Users/josep/movie data/4.txt", header = FALSE, sep = ",", dec = ".")
movie3<- movie3[,1:2]
movie3<- cbind(movie_id,movie3)
```


```{r}
movies<- rbind(movie1, movie2, movie3)

```

```{r}
dim(movies)

```

name v1 to be userid

```{r}
ratingsMatrix <- dcast(movies, V1~movie_id, value.var = "V2" )

```


substract user id from actual data


```{r}
ratingsMatrix <- as.matrix(ratingsMatrix[-c(1)])
```
  
  
  make a realrating matix
  
```{r}
# Convert rating matrix into a recommenderlab sparse matrix
ratingsMatrix <- as(ratingsMatrix, "realRatingMatrix")

ratingsMatrix
```


display it
```{r}
getRatingMatrix(ratingsMatrix)
```   

show ratings 
```{r}
getRatings(ratingsMatrix)
```
a more condensed look
```{r}
vec_ratings <- as.vector(ratingsMatrix@data)

# Unique ratings
unique(vec_ratings)
```

```{r}
( ratingsMatrix <- ratingsMatrix[ , colCounts(ratingsMatrix) != 0] )

```

```{r}
table(rowCounts(ratingsMatrix))
```
# divide up the data 

```{r}
evaluation <- evaluationScheme(ratingsMatrix, method = "split", train = 0.80, given = 1)

evaluation
```

```{r}
train <- getData(evaluation, "train")
train
```

```{r}
test_known <- getData(evaluation, "known")
test_known
```

```{r}
test_unknown <- getData(evaluation, "unknown")
test_unknown
```
do the ame for 
RANDOM works , LIBMF MAYBE WORKS

```{r}
set.seed(123)
rec_als <- Recommender(data = train, method = "POPULAR")

pred_als_acr <- predict(object = rec_als, newdata = test_unknown, type = "ratings")
pred_als_acr
```


```{r}
model1_pred <- predict(rec_als, newdata = test_known, type = "ratings")
as(model1_pred ,"matrix")
```


```{r}
getRatingMatrix(model1_pred)
```

```{r}

test_error <- calcPredictionAccuracy(model1_pred, test_unknown)
test_error
```



```{r}
getModel(rec_als)
```

```{r}
getModel(rec_als)$topN
```

The result contains two ordered top-N recommendation lists, one for each user. 
The recommended items can be inspected as a list.
```{r}
recom <- predict(rec_als, test_known, n=3)
head(as(recom,"list"))
```
```{r}
recom3 <- bestN(recom, n = 3)
head(as(recom3, "list"))

```

do the same step for random



and svbm






conclusion


-------


```{r}
bookratings <- read.csv("C:/Users/josep/OneDrive/Documents/Data-607-Projects/Final Project/ratings.csv", header = TRUE, sep = ",", dec = ".")

```
Check the class for each column since pare matrix and rea matrix are very partovulat

```{r}
bookratings
```


```{r}
class(bookratings$User.ID); class(bookratings$ISBN); class(bookratings$Book.Rating);
```
```{r}
booksratings <- sample_n(bookratings, 10000)
```


had to change this  to factors
```{r}
bookratings$ISBN <- as.factor(bookratings$ISBN)
```

Convert into ratings matrix

```{r}
ratingsMatrix <- sparseMatrix(as.integer(bookratings$User.ID), as.integer(bookratings$ISBN), x = bookratings$Book.Rating)
colnames(ratingsMatrix) <- levels(bookratings$ISBN)
rownames(ratingsMatrix) <- levels(bookratings$User.ID)
books <- as(ratingsMatrix, "realRatingMatrix")
```

```{r}
getRatingMatrix(books)[1:10,1:4]
```



```{r}
(rowCounts(books))
```

```{r}
table(colCounts(books))
```

```{r}
( books <- books[ , colCounts(books) != 0] )
```



```{r}
books_subset <- books[ , colCounts(books) > 30]
books_subset <- books_subset[rowCounts(books_subset) > 10, ]
books_subset
```


```{r}

getRatingMatrix(books_subset)[1:10,1:4]
```

```{r}
getRatings(books_subset)
```


# Divide the data 
Good rating is 5, the ratings go all the way up to 10

```{r}
set.seed(88)
eval <- evaluationScheme(books_subset, method = "split", train = 0.8, given = 5, goodRating = 5)
train <- getData(eval, "train")
known <- getData(eval, "known")
unknown <- getData(eval, "unknown")
```


```{r}
model_method <- "POPULAR"
# Training

modelPOP <- Recommender(train, method = model_method)
```


```{r}

predPOP <- predict(modelPOP, newdata = known, type = "ratings")


# Accuracy
accPOP <- calcPredictionAccuracy(predPOP, unknown)
```



```{r}
accPOP
```

# USBF


```{r}
set.seed(88)
eval <- evaluationScheme(books_subset, method = "split", train = 0.8, given = 5, goodRating = 5)
train <- getData(eval, "train")
known <- getData(eval, "known")
unknown <- getData(eval, "unknown")
```


```{r}
model_method <- "UBCF"
# Training


model_params <- list(method = "cosine",
                     nn = 10, # find each user's 10 most similar users.
                     sample = FALSE, # already did this.
                     normalize = "center")

modelPOP <-  getData(eval, "train") %>% Recommender( method = model_method, parameter= model_params)
```


```{r}

predPOP <- predict(modelPOP, newdata = known, type = "ratings")

```


Takes forever
# Accuracy
```{r}
accPOP <- calcPredictionAccuracy(predPOP, unknown)
```



```{r}
accPOP
```



```{r}

```






# Conclusions





references


https://www.kaggle.com/datasets/arashnic/book-recommendation-dataset?select=Ratings.csv

https://www.kaggle.com/datasets/skillsmuggler/amazon-ratings

data : https://www.kaggle.com/code/laowingkin/netflix-movie-recommendation/data

https://www.data-mania.com/blog/how-to-build-a-recommendation-engine-in-r/

https://github.com/BrandonHoeft/Recommender-System-R-Tutorial/blob/master/RecommenderLab_Tutorial.md



https://cran.r-project.org/web/packages/recommenderlab/vignettes/recommenderlab.pdf
